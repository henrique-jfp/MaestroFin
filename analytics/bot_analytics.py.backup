"""
Sistema de Analytics e Monitoramento - MaestroFin Bot
Coleta m√©tricas detalhadas de uso, erros e performance
"""

import sqlite3
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
import logging
import functools

class BotAnalytics:
    def __init__(self, db_path: str = "analytics.db"):
        self.db_path = db_path
        self.init_database()
        
    def init_database(self):
        """Inicializa tabelas de analytics"""
        with sqlite3.connect(self.db_path) as conn:
            conn.executescript("""
                -- Tabela de eventos de comandos
                CREATE TABLE IF NOT EXISTS command_usage (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    command TEXT NOT NULL,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    success BOOLEAN DEFAULT TRUE,
                    execution_time_ms INTEGER,
                    parameters TEXT -- JSON com par√¢metros extras
                );
                
                -- Tabela de acessos di√°rios √∫nicos
                CREATE TABLE IF NOT EXISTS daily_users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    date DATE NOT NULL,
                    first_command TEXT,
                    total_commands INTEGER DEFAULT 1,
                    UNIQUE(user_id, date)
                );
                
                -- Tabela de eventos de doa√ß√£o
                CREATE TABLE IF NOT EXISTS donation_events (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    event_type TEXT NOT NULL, -- 'donation_message_shown', 'donation_clicked', 'donation_completed'
                    amount REAL,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    metadata TEXT -- JSON com dados extras
                );
                
                -- Tabela de logs de erros
                CREATE TABLE IF NOT EXISTS error_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    username TEXT,
                    command TEXT,
                    error_type TEXT NOT NULL,
                    error_message TEXT NOT NULL,
                    stack_trace TEXT,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    metadata TEXT -- JSON com contexto adicional
                );
                
                -- Tabela de m√©tricas de performance
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    metric_name TEXT NOT NULL,
                    metric_value REAL NOT NULL,
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    metadata TEXT
                );
                
                -- Tabela de sess√µes de usu√°rio
                CREATE TABLE IF NOT EXISTS user_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    session_start DATETIME DEFAULT CURRENT_TIMESTAMP,
                    session_end DATETIME,
                    commands_count INTEGER DEFAULT 0,
                    duration_minutes INTEGER
                );
                
                -- üÜï Tabela de funil de onboarding
                CREATE TABLE IF NOT EXISTS onboarding_funnel (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    step_name TEXT NOT NULL, -- 'start', 'profile_setup', 'account_setup', 'first_transaction', etc.
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    completed BOOLEAN DEFAULT TRUE,
                    metadata TEXT -- JSON com dados extras do passo
                );
                
                -- üÜï Tabela de cohort analysis
                CREATE TABLE IF NOT EXISTS user_cohorts (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    cohort_week TEXT NOT NULL, -- 'YYYY-WW' format
                    first_activity_date DATE NOT NULL,
                    registration_date DATE NOT NULL
                );
                
                -- üÜï Tabela de m√©tricas de performance da IA
                CREATE TABLE IF NOT EXISTS ai_performance (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    username TEXT,
                    operation_type TEXT NOT NULL, -- 'ocr', 'intent_detection', 'response_generation'
                    success BOOLEAN NOT NULL,
                    response_time_ms INTEGER,
                    confidence_score REAL, -- Para opera√ß√µes de IA que retornam confian√ßa
                    input_size INTEGER, -- Tamanho do input (caracteres, KB, etc.)
                    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                    metadata TEXT -- JSON com detalhes espec√≠ficos
                );
                
                -- üÜï Tabela de qualidade dos dados do usu√°rio
                CREATE TABLE IF NOT EXISTS data_quality_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    username TEXT,
                    metric_name TEXT NOT NULL, -- 'accounts_count', 'cards_count', 'uncategorized_transactions', etc.
                    metric_value INTEGER NOT NULL,
                    calculation_date DATE DEFAULT (DATE('now')),
                    metadata TEXT
                );
                
                -- √çndices para performance
                CREATE INDEX IF NOT EXISTS idx_command_usage_user_date 
                ON command_usage(user_id, DATE(timestamp));
                
                CREATE INDEX IF NOT EXISTS idx_daily_users_date 
                ON daily_users(date);
                
                CREATE INDEX IF NOT EXISTS idx_error_logs_timestamp 
                ON error_logs(timestamp);
            """)
    
    def track_command_usage(self, user_id: int, username: str, command: str, 
                           success: bool = True, execution_time_ms: int = 0,
                           parameters: Dict = None):
        """Registra uso de comando"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO command_usage (user_id, username, command, success, execution_time_ms, parameters)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (user_id, username, command, success, execution_time_ms, 
                 json.dumps(parameters) if parameters else None))
            
        # Atualizar usu√°rio di√°rio
        self._update_daily_user(user_id, username, command)
    
    def _update_daily_user(self, user_id: int, username: str, command: str):
        """Atualiza estat√≠sticas de usu√°rio di√°rio"""
        today = datetime.now().date()
        
        with sqlite3.connect(self.db_path) as conn:
            # Tentar inserir novo usu√°rio do dia
            conn.execute("""
                INSERT OR IGNORE INTO daily_users (user_id, username, date, first_command, total_commands)
                VALUES (?, ?, ?, ?, 1)
            """, (user_id, username, today, command))
            
            # Incrementar contagem de comandos
            conn.execute("""
                UPDATE daily_users 
                SET total_commands = total_commands + 1,
                    username = ?
                WHERE user_id = ? AND date = ?
            """, (username, user_id, today))
    
    def track_donation_event(self, user_id: int, username: str, event_type: str,
                            amount: float = None, metadata: Dict = None):
        """Registra eventos relacionados a doa√ß√µes"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO donation_events (user_id, username, event_type, amount, metadata)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, username, event_type, amount, 
                 json.dumps(metadata) if metadata else None))
    
    def log_error(self, error_type: str, error_message: str, stack_trace: str = None,
                  user_id: int = None, username: str = None, command: str = None,
                  metadata: Dict = None):
        """Registra erro no sistema"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO error_logs (user_id, username, command, error_type, 
                                       error_message, stack_trace, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (user_id, username, command, error_type, error_message, 
                 stack_trace, json.dumps(metadata) if metadata else None))
    
    def get_daily_stats(self, date: str = None) -> Dict[str, Any]:
        """Retorna estat√≠sticas do dia"""
        if not date:
            date = datetime.now().date()
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Usu√°rios √∫nicos
            unique_users = conn.execute("""
                SELECT COUNT(*) as count FROM daily_users WHERE date = ?
            """, (date,)).fetchone()['count']
            
            # Total de comandos
            total_commands = conn.execute("""
                SELECT COUNT(*) as count FROM command_usage WHERE DATE(timestamp) = ?
            """, (date,)).fetchone()['count']
            
            # Comandos mais usados
            top_commands = conn.execute("""
                SELECT command, COUNT(*) as count
                FROM command_usage 
                WHERE DATE(timestamp) = ?
                GROUP BY command 
                ORDER BY count DESC 
                LIMIT 10
            """, (date,)).fetchall()
            
            # Erros do dia
            errors_count = conn.execute("""
                SELECT COUNT(*) as count FROM error_logs WHERE DATE(timestamp) = ?
            """, (date,)).fetchone()['count']
            
            return {
                'date': str(date),
                'unique_users': unique_users,
                'total_commands': total_commands,
                'top_commands': [dict(row) for row in top_commands],
                'errors_count': errors_count
            }
    
    def get_weekly_stats(self, weeks_back: int = 0) -> Dict[str, Any]:
        """Retorna estat√≠sticas da semana"""
        end_date = datetime.now().date() - timedelta(weeks=weeks_back)
        start_date = end_date - timedelta(days=6)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Usu√°rios √∫nicos da semana
            unique_users = conn.execute("""
                SELECT COUNT(DISTINCT user_id) as count 
                FROM daily_users 
                WHERE date BETWEEN ? AND ?
            """, (start_date, end_date)).fetchone()['count']
            
            # Total de comandos
            total_commands = conn.execute("""
                SELECT COUNT(*) as count 
                FROM command_usage 
                WHERE DATE(timestamp) BETWEEN ? AND ?
            """, (start_date, end_date)).fetchone()['count']
            
            # Crescimento por dia
            daily_growth = conn.execute("""
                SELECT date, COUNT(*) as users
                FROM daily_users 
                WHERE date BETWEEN ? AND ?
                GROUP BY date
                ORDER BY date
            """, (start_date, end_date)).fetchall()
            
            return {
                'period': f"{start_date} a {end_date}",
                'unique_users': unique_users,
                'total_commands': total_commands,
                'daily_growth': [dict(row) for row in daily_growth]
            }
    
    def get_donation_stats(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas de doa√ß√µes"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Mensagens de doa√ß√£o mostradas
            donations_shown = conn.execute("""
                SELECT COUNT(*) as count 
                FROM donation_events 
                WHERE event_type = 'donation_message_shown'
            """).fetchone()['count']
            
            # Cliques em doa√ß√£o
            donations_clicked = conn.execute("""
                SELECT COUNT(*) as count 
                FROM donation_events 
                WHERE event_type = 'donation_clicked'
            """).fetchone()['count']
            
            # Doa√ß√µes completadas
            donations_completed = conn.execute("""
                SELECT COUNT(*) as count, SUM(amount) as total_amount
                FROM donation_events 
                WHERE event_type = 'donation_completed'
            """).fetchone()
            
            # Taxa de convers√£o
            conversion_rate = 0
            if donations_shown > 0:
                conversion_rate = (donations_completed['count'] / donations_shown) * 100
            
            return {
                'donations_shown': donations_shown,
                'donations_clicked': donations_clicked,
                'donations_completed': donations_completed['count'],
                'total_amount': donations_completed['total_amount'] or 0,
                'conversion_rate': round(conversion_rate, 2)
            }
    
    def get_error_summary(self, days_back: int = 7) -> Dict[str, Any]:
        """Retorna resumo de erros"""
        cutoff_date = datetime.now() - timedelta(days=days_back)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Erros por tipo
            errors_by_type = conn.execute("""
                SELECT error_type, COUNT(*) as count
                FROM error_logs 
                WHERE timestamp >= ?
                GROUP BY error_type
                ORDER BY count DESC
            """, (cutoff_date,)).fetchall()
            
            # Erros recentes
            recent_errors = conn.execute("""
                SELECT error_type, error_message, command, timestamp, username
                FROM error_logs 
                WHERE timestamp >= ?
                ORDER BY timestamp DESC
                LIMIT 20
            """, (cutoff_date,)).fetchall()
            
            return {
                'period_days': days_back,
                'errors_by_type': [dict(row) for row in errors_by_type],
                'recent_errors': [dict(row) for row in recent_errors]
            }
    
    def track_onboarding_step(self, user_id: int, username: str, step_name: str, 
                             completed: bool = True, metadata: Dict = None):
        """Rastreia passos do funil de onboarding"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO onboarding_funnel (user_id, username, step_name, completed, metadata)
                VALUES (?, ?, ?, ?, ?)
            """, (user_id, username, step_name, completed, 
                 json.dumps(metadata) if metadata else None))
    
    def track_ai_performance(self, operation_type: str, success: bool, response_time_ms: int,
                           user_id: int = None, username: str = None, 
                           confidence_score: float = None, input_size: int = None,
                           metadata: Dict = None):
        """Rastreia performance das opera√ß√µes de IA"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                INSERT INTO ai_performance 
                (user_id, username, operation_type, success, response_time_ms, 
                 confidence_score, input_size, metadata)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (user_id, username, operation_type, success, response_time_ms,
                 confidence_score, input_size, 
                 json.dumps(metadata) if metadata else None))
    
    def update_user_data_quality(self, user_id: int, username: str, 
                                accounts_count: int = 0, cards_count: int = 0,
                                uncategorized_transactions: int = 0):
        """Atualiza m√©tricas de qualidade dos dados do usu√°rio"""
        today = datetime.now().date()
        
        with sqlite3.connect(self.db_path) as conn:
            metrics = {
                'accounts_count': accounts_count,
                'cards_count': cards_count, 
                'uncategorized_transactions': uncategorized_transactions
            }
            
            for metric_name, metric_value in metrics.items():
                conn.execute("""
                    INSERT OR REPLACE INTO data_quality_metrics 
                    (user_id, username, metric_name, metric_value, calculation_date)
                    VALUES (?, ?, ?, ?, ?)
                """, (user_id, username, metric_name, metric_value, today))
    
    def get_onboarding_funnel(self, days_back: int = 30) -> Dict[str, Any]:
        """Retorna dados do funil de onboarding"""
        cutoff_date = datetime.now() - timedelta(days=days_back)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Passos do funil e completa√ß√£o
            funnel_data = conn.execute("""
                WITH funnel_steps AS (
                    SELECT 
                        step_name,
                        COUNT(DISTINCT user_id) as users_reached,
                        COUNT(DISTINCT CASE WHEN completed THEN user_id END) as users_completed
                    FROM onboarding_funnel 
                    WHERE timestamp >= ?
                    GROUP BY step_name
                )
                SELECT 
                    step_name,
                    users_reached,
                    users_completed,
                    ROUND(users_completed * 100.0 / users_reached, 2) as completion_rate
                FROM funnel_steps
                ORDER BY users_reached DESC
            """, (cutoff_date,)).fetchall()
            
            return {
                'period': f'{cutoff_date.date()} a {datetime.now().date()}',
                'funnel_steps': [dict(row) for row in funnel_data]
            }
    
    def get_cohort_analysis(self, weeks_back: int = 12) -> Dict[str, Any]:
        """Retorna an√°lise de cohort por semana"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Criar cohorts baseado na primeira atividade
            cohort_data = conn.execute("""
                WITH user_cohorts AS (
                    SELECT 
                        user_id,
                        username,
                        strftime('%Y-W%W', MIN(date)) as cohort_week,
                        MIN(date) as first_activity
                    FROM daily_users
                    GROUP BY user_id
                ),
                cohort_retention AS (
                    SELECT 
                        uc.cohort_week,
                        COUNT(DISTINCT uc.user_id) as cohort_size,
                        COUNT(DISTINCT CASE 
                            WHEN julianday(du.date) - julianday(uc.first_activity) <= 7 
                            THEN uc.user_id END) as week_1_retained,
                        COUNT(DISTINCT CASE 
                            WHEN julianday(du.date) - julianday(uc.first_activity) <= 30 
                            THEN uc.user_id END) as week_4_retained
                    FROM user_cohorts uc
                    LEFT JOIN daily_users du ON uc.user_id = du.user_id
                    WHERE uc.cohort_week >= strftime('%Y-W%W', date('now', '-' || ? || ' weeks'))
                    GROUP BY uc.cohort_week
                )
                SELECT 
                    cohort_week,
                    cohort_size,
                    week_1_retained,
                    week_4_retained,
                    ROUND(week_1_retained * 100.0 / cohort_size, 2) as retention_week_1,
                    ROUND(week_4_retained * 100.0 / cohort_size, 2) as retention_week_4
                FROM cohort_retention
                ORDER BY cohort_week DESC
                LIMIT ?
            """, (weeks_back, weeks_back)).fetchall()
            
            return {
                'period': f'√öltimas {weeks_back} semanas',
                'cohorts': [dict(row) for row in cohort_data]
            }
    
    def get_ai_performance_stats(self, days_back: int = 7) -> Dict[str, Any]:
        """Retorna estat√≠sticas de performance da IA"""
        cutoff_date = datetime.now() - timedelta(days=days_back)
        
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            
            # Performance por tipo de opera√ß√£o
            performance_by_type = conn.execute("""
                SELECT 
                    operation_type,
                    COUNT(*) as total_operations,
                    COUNT(CASE WHEN success THEN 1 END) as successful_operations,
                    ROUND(AVG(response_time_ms), 2) as avg_response_time,
                    ROUND(AVG(CASE WHEN confidence_score IS NOT NULL 
                              THEN confidence_score END), 3) as avg_confidence,
                    ROUND(COUNT(CASE WHEN success THEN 1 END) * 100.0 / COUNT(*), 2) as success_rate
                FROM ai_performance 
                WHERE timestamp >= ?
                GROUP BY operation_type
            """, (cutoff_date,)).fetchall()
            
            """, (cutoff_date,)).fetchall()
            
            return {
                'period': f'{cutoff_date.date()} a {datetime.now().date()}',
                'performance_by_type': [dict(row) for row in performance_by_type]
            }


# Singleton para uso global
analytics = BotAnalytics()

def track_command(command_name: str):
```
